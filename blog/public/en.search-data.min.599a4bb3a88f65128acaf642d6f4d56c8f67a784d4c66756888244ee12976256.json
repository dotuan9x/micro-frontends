[{"id":0,"href":"/docs/example/iframes/","title":"Iframes","section":"Ví dụ","content":"Iframe example\r#\r\rĐể triển khai iframe thì đơn giản khỏi phải nói luôn. Ta chỉ cần chèn HTML tag \u0026lt;iframe src=\u0026quot;example.com\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt; là có ngay một app khác xịn sò vào trong ứng dụng của mình liền.\nDemo: Mình sẽ demo iframe bằng cách gắn một app khác (app products hiện thị các sản phẩm liên quan) vào một app chính như hình bên dưới.\nTrong file App.jsx của project container đã chèn HTML tag iframe như bên dưới, và kết quả sẽ như hình bên trên. Ta có chức năng Related products nằm bên trong app container\n// iframes/container/src/App.jsx \u0026lt;div className=\u0026#34;p-1\u0026#34; style={{width: 210}}\u0026gt; \u0026lt;iframe className=\u0026#34;w-full h-full\u0026#34; src=\u0026#34;https://micro-frontends.tuando.net/demo/react-example/products#/\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \rSource code\r\rDemo\r\r"},{"id":1,"href":"/docs/table-of-contents/when-to-use/","title":"Khi nào ta nên nghĩ tới việc sử dụng Micro Frontends","section":"Micro Frontends","content":"Khi nào ta nên nghĩ tới việc sử dụng Micro Frontends\r#\r\rMột số trường hợp sau đây, chúng ta có thể sử dụng Micro Frontends\nMột sản phẩm có nhiều module chức năng và bạn muốn nhiều team có thể phát triển cùng lúc\nCó thể bạn sẽ muốn phát triển một progressive hoặc responsive web application nhưng bạn gặp khó khăn trong việc tích hợp vào source code hiện tại của mình\nCó thể bạn muốn sử dụng một thư viện mới để tăng tốc quá trình phát triển sản phẩm của mình (vd: trước đó sử dụng Angularjs (1.x) để phát triển và hiện tại muốn sử dụng ReactJS để phát triển)\nBạn muốn sử dụng một thư viện mới để hỗ trợ cho các chức năng sản phẩm, như sử dụng Webpack 5.x nhưng project hiện tại đang sử dụng Webpack 3.x và khó có thể nâng cấp lên Webpack 5.x được vì có khá nhiều dependence bị ảnh hưởng.\nCó thể bạn muốn tăng tốc quá trình phát triển sản phẩm bằng cách nhiều team khác nhau tham gia vào phát triển một sản phẩm cùng lúc bằng việc tách ra nhiều module và phát triển độc lập.\nVà rất nhiều lý do khác\u0026hellip;\n"},{"id":2,"href":"/docs/table-of-contents/advantages-and-disadvantages/","title":"Một số ưu điểm và nhược điểm của Micro Frontends","section":"Micro Frontends","content":"Một số ưu điểm và nhược điểm của Micro Frontends\r#\r\rƯu điểm\r#\r\r  Tách biệt các module chức năng thành nhiều phần source code riêng biệt. Từ đó giảm các dependencies ở mỗi project, lượng code sẽ ít hơn, giúp cho quá trình build deploy nhanh hơn và các file js bundle cũng sẽ nhẹ hơn\n  Có khả năng mở rộng một cách dễ dàng bằng cách nhiều team cùng tham gia.\n  Có thể sử dụng các thư viện, framework khác nhau (React, Angular) để phát triển các module khác nhau của một dự án.\n  Có khả năng cập nhật, nâng cấp thư viện hoặc phát triển lại một phần nào đó của dự án.\n  Dễ dàng kiểm thử (testing) các chức năng một cách độc lập.\n  Nhược điểm\r#\r\r  Chia nhỏ các dự án sẽ dẫn tới trùng lập các dependencies hoặc source code\n  Nhiều team phát triển nên khó trong việc quản lý source code nếu không có quy định chung rõ ràng từ ban đầu.\n  "},{"id":3,"href":"/docs/example/run-time-integration/","title":"Run-time integration via JavaScript","section":"Ví dụ","content":"Run-time integration via JavaScript\r#\r\rTrong React thông thường file index.jsx ta sẽ render \u0026lt;App /\u0026gt; vào trong một div element có id là root như \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\n// /run-time-integration/products/src/index.jsx import React from \u0026#34;react\u0026#34;; import ReactDOM from \u0026#34;react-dom\u0026#34;; import App from \u0026#34;./App\u0026#34;; ReactDOM.render(\u0026lt;App /\u0026gt;, document.getElementById(\u0026#34;root\u0026#34;)); Ta sẽ chỉnh lại như sau, khai báo một function global renderProducts truyển vào parameter containerId và tiến hành sử dụng ReactDOM render \u0026lt;App /\u0026gt; vào trong element này.\n// /run-time-integration/products/src/index.jsx import React from \u0026#34;react\u0026#34;; import ReactDOM from \u0026#34;react-dom\u0026#34;; import App from \u0026#34;./App\u0026#34;; window.renderProducts = (containerId, history) =\u0026gt; { ReactDOM.render( \u0026lt;App history={history} /\u0026gt;, document.getElementById(containerId), ); }; Trong file index.html của container, ta load script file bundle của project products và sau đó gọi global function renderProducts để render app products vào trong ứng dụng container\n\u0026lt;!-- /run-time-integration/container/public/index.html --\u0026gt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;The Model Store\u0026lt;/title\u0026gt; \u0026lt;link href=\u0026#34;https://unpkg.com/tailwindcss@2.2.7/dist/tailwind.min.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; \u0026lt;!-- Load file bundle của project products --\u0026gt; \u0026lt;script src=\u0026#34;http://localhost:8002/main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;root\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- Gọi function renderProducts để render app products vào element id có name products --\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; window.onload = () =\u0026gt; { window.renderProducts(\u0026#39;products\u0026#39;) } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Và kết quả sẽ như sau, ứng dụng container đã có thêm phần Related products của ứng dụng products Source code\r\rDemo\r\r"},{"id":4,"href":"/docs/table-of-contents/method/","title":"Một số phương pháp triển khai Micro Frontends","section":"Micro Frontends","content":"Một số phương pháp triển khai Micro Frontends\r#\r\rBuild-time integration\r#\r\rlà việc coi các ứng dụng như một package và ứng dụng chính sẽ thêm các ứng dụng con như một thư viện như sau:\n{ \u0026#34;name\u0026#34;: \u0026#34;@micro-frontends/container\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Micro frontends demo\u0026#34;, \u0026#34;dependencies\u0026#34;: { \u0026#34;@micro-frontends/products\u0026#34;: \u0026#34;^1.2.3\u0026#34;, \u0026#34;@micro-frontends/checkout\u0026#34;: \u0026#34;^4.5.6\u0026#34;, \u0026#34;@micro-frontends/user-profile\u0026#34;: \u0026#34;^7.8.9\u0026#34; } } Cách tiếp cận này có một số hạn chế như:\n Chúng ta sẽ phải re-compile (bundle) các ứng dụng chính và release lại mỗi khi các ứng dụng con có thay đổi (release version mới từ 0.0.1 ⇒ 0.02) Không có sự đồng bộ chức năng giữa các ứng dụng chính nếu chúng ta bỏ xót quá trình đồng bộ version của ứng dụng con (Cũng có thể là một điểm lợi nếu chúng ta không muốn nâng cấp chức năng ở một trang nào đó) Phụ thuộc các dependencies với nhau  Nếu project @micro-frontends/container sử dụng React và @micro-frontends/products cũng sử dụng React thì sẽ bị trùng lập thư viện và tăng dung lượng khi tải trang web Nếu project @micro-frontends/container sử dụng React và @micro-frontends/products sử dụng chung React với project chính thì sẽ bị phụ thuộc vào version của project chính.    Run-time integration via iframes\r#\r\r\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Micro frontends\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Welcome to Micro frontends\u0026lt;/h1\u0026gt; \u0026lt;iframe id=\u0026#34;micro-frontend-container\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; const microFrontendsByRoute = { \u0026#39;/\u0026#39;: \u0026#39;https://micro-frontends.tuando.net/demo/react-example\u0026#39;, \u0026#39;/products\u0026#39;: \u0026#39;https://micro-frontends.tuando.net/demo/react-example/products\u0026#39; }; const iframe = document.getElementById(\u0026#39;micro-frontend-container\u0026#39;); iframe.src = microFrontendsByRoute[window.location.pathname]; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Mỗi lần thay đổi url từ / sang /products phần nội dụng của trang sẽ được tải lại bởi một nội dung từ domain khác, trong ví dụ là https://micro-frontends.tuando.net/demo/react-example/products.\nDemo chi tiết: https://micro-frontends.tuando.net/docs/example/iframes/\nƯu điểm:\n Không bị ảnh hưởng bởi styles (CSS) giữa các trang chính và trang trong iframe  Hạn chế:\n Phải tải lại toàn bộ trang khi thay đổi đường dẫn Khó khăn trong việc giao tiếp giữa các chức năng  Run-time integration via JavaScript\r#\r\rCác tiếp cận này là việc chúng ta khai báo các global function hỗ trợ render các chức năng ở dự án con. Sau đó ở dự án chính ta sẽ gắn các script bundle file của các dự án con, tiếp theo cần hiện thị chức năng nào thì chỉ việc gọi chức năng đó thôi.\nimport React from \u0026#34;react\u0026#34;; import ReactDOM from \u0026#34;react-dom\u0026#34;; import App from \u0026#34;./App\u0026#34;; window.renderProducts = (containerId, history) =\u0026gt; { ReactDOM.render( \u0026lt;App history={history} /\u0026gt;, document.getElementById(containerId), ); }; Chi tiết demo: https://micro-frontends.tuando.net/docs/example/run-time-integration/\nRun-time integration via Web Components\r#\r\rCách tiếp cận này cho phép chúng ta khai báo một HTML Custom Element, ví dụ như ta khai báo một HTML Custom Element \u0026lt;web-components-products\u0026gt;\u0026lt;/web-components-products\u0026gt; thì chỗ nào muốn sử dụng ta chỉ cần chèn đoạn mã \u0026lt;web-components-products\u0026gt;\u0026lt;/web-components-products\u0026gt; là có thể sử dụng được rồi.\nChi tiết demo: https://micro-frontends.tuando.net/docs/example/web-components/\nƯu điểm:\n Không bị phụ thuộc dependencies giữa các dự án với nhau (ví dụ: khác version React giữa các dự án) Vì cho phép tạo một HTML Custom Element nên ta có thể gắn thẻ HTML Custom này vào bất cứ đoạn mã HTML nào, không quan trọng dự án đó đang sử dụng frontend framework nào Hỗ trợ Shadow DOM: cho phép style css độc lập, không ảnh hưởng css giữa các dự án với nhau Có thể phát triển theo hướng package (publish lên một registry) mà không cần phải có domain host cho dự án vì vậy đơn giản trong việc quản lý các version release.  Hạn chế:\n Không thể chia sẻ tài nguyên giữa các dự án với nhau (ví dụ: sử dụng chung thư viện React)  Module Federation Webpack 5\r#\r\rModule Federation là một tính năng mới của Webpack 5. Nó cho phép chúng ta cấu hình để một ứng dụng có thể dynamic load code từ một ứng dụng khác.\nHiểu đơn giản là chúng ta có 2 ứng dụng được phát triển độc lập A và B, ứng dụng B là một phần nhỏ chức năng của ứng dụng A. Module Federation sẽ cho phép ta nhúng ứng dụng B và ứng dụng A và chia sẻ tài nguyên giữa chúng.\nChi tiết các bạn tham khảo tài liệu tại Module Federation và các ví dụ tại Module Federation Examples\nChi tiết demo:\nWeb components trong React\nWeb components trong React kết hợp Redux\nƯu điểm:\n Có thể chia sẻ tài nguyên giữa các dự án. Ví dụ dự án A sử dụng React 16.x và dự án B cũng sử dụng React 16.x thì khi tải module B sẽ không cần phải tải thêm React một lần nữa, nếu 2 version khác nhau thì nó sẽ tự động tải thêm version React còn thiếu. Giao tiếp giữa các dự án một cách đơn giản, có thể sử dụng chung một Redux store giữa các dự án với nhau  Hạn chế:\n Các dự án phải sử dụng Module Federation của Webpack 5.x Buộc phải các dự án phải có các static domain để tải các bundle file tương ứng. Vì các chức năng Module Federation chỉ hỗ trợ cấu hình tải các file từ một remote url  Tài liệu tham khảo:\r#\r\rhttps://martinfowler.com/articles/micro-frontends.html\nhttps://micro-frontends.org/\n"},{"id":5,"href":"/docs/example/web-components/","title":"Web components","section":"Ví dụ","content":"Web components\r#\r\rĐể khai báo một HTML Custom Element ta thực hiện như sau:\n// /web-components/products/src/index.jsx import React from \u0026#34;react\u0026#34;; import ReactDOM from \u0026#34;react-dom\u0026#34;; import App from \u0026#34;./App\u0026#34;; class Webcomponents extends HTMLElement { constructor() { super(); } connectedCallback() { ReactDOM.render(\u0026lt;App /\u0026gt;, this); } } customElements.define(\u0026#39;web-components-products\u0026#39;, Webcomponents); Trong file index.html của project container ta load bundle file của project products\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;The Model Store\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://micro-frontends.tuando.net/demo/web-components/products/dist/main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;root\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Tiếp đến ta gắn HTML ta  \u0026lt;web-components-products /\u0026gt; vào chỗ cần hiện thị trong project container\nimport React from \u0026#39;react\u0026#39;; const App = () =\u0026gt; { return ( \u0026lt;\u0026gt; \u0026lt;h1\u0026gt;The model store\u0026lt;/h1\u0026gt; \u0026lt;web-components-products /\u0026gt; \u0026lt;/\u0026gt; ) }; export default OneLoyaltyTechcombank; Source code\r\rDemo\r\r"},{"id":6,"href":"/docs/example/react-example/","title":"Module Federation React Example","section":"Ví dụ","content":"Module Federation React Example\r#\r\rModule Federation là một plugin của webpack 5, nên ta tiến hành cấu hình webpack như sau:\nImport ModuleFederationPlugin của webpack (lưu ý module này chỉ có trong webpack 5 trở lên)\n// webpack.config const {ModuleFederationPlugin} = require(\u0026#39;webpack\u0026#39;).container; Sau đó ta cấu hình plugin trong project products như sau\n// webpack.config (products project)  plugins: [ new ModuleFederationPlugin({ name: \u0026#39;Products\u0026#39;, library: {type: \u0026#39;var\u0026#39;, name: \u0026#39;Products\u0026#39;}, filename: \u0026#39;products.js\u0026#39;, exposes: { \u0026#39;./App\u0026#39;: \u0026#39;./src/App\u0026#39;, }, shared: { \u0026#39;react\u0026#39;: { eager: true, singleton: true, requiredVersion: dependencies.react, }, \u0026#39;react-dom\u0026#39;: { eager: true, singleton: true, } } }), new HTMLWebpackPlugin({ template: path.resolve(\u0026#39;public/index.html\u0026#39;), filename: \u0026#39;./index.html\u0026#39;, chunksSortMode: \u0026#39;none\u0026#39; }) ] Tiếp đó ta cấu hình webpack của project container như sau\nplugins: [ new ModuleFederationPlugin({ name: \u0026#39;container\u0026#39;, remotes: { Products: \u0026#39;Products@http://localhost:8002/products.js\u0026#39;, } }), new HTMLWebpackPlugin({ template: path.resolve(\u0026#39;public/index.html\u0026#39;), filename: \u0026#39;./index.html\u0026#39;, chunksSortMode: \u0026#39;none\u0026#39; }) ] Với thông tin cấu hình trên ta chú ý đoạn 'Products@http://localhost:8002/products.js' thì Products là giá trị name trong phần cấu hình  library: {type: 'var', name: 'Products'} của file webpack của project products\nVà http://localhost:8002/products.js và domain và file bundle của project products sau khi được start lên\nSau đó khi sử dụng ta chỉ việc import như một thư viện hoặc một component bình thường\nimport React from \u0026#39;react\u0026#39;; const RelatedProducts = React.lazy(() =\u0026gt; import(\u0026#39;Products/App\u0026#39;)); function App() { return ( \u0026lt;React.Suspense fallback={null}\u0026gt; \u0026lt;RelatedProducts /\u0026gt; \u0026lt;/React.Suspense\u0026gt; ) } export default App; Và kết quả sẽ như hình bên dưới\nSource code\r\rDemo\r\r"},{"id":7,"href":"/docs/example/react-redux/","title":"Module Federation React Redux","section":"Ví dụ","content":"Module Federation React Redux\r#\r\rTương tự như phần Module Federation React Example nhưng trong demo này có sử dụng Redux để giao tiếp giữa 2 app với nhau.\nCụ thể là với demo bên dưới bạn có thể click vào sản phẩm ở phần Related products thì sản phẩm chính bên app container sẽ thay đổi theo\nSource code\r\rDemo\r\r"},{"id":8,"href":"/posts/post-one/","title":"Post One","section":"Posts","content":"posts post one\n"}]