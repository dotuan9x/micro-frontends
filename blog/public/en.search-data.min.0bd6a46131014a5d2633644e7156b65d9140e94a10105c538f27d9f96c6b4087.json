[{"id":0,"href":"/docs/example/iframes/","title":"Iframes","section":"Ví dụ","content":"Iframe example\r#\r\rĐể triển khai iframe thì đơn giản khỏi phải nói luôn. Ta chỉ cần chèn HTML tag \u0026lt;iframe src=\u0026quot;mico-frontends.tuando.net\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt; là có ngay một app khác xịn sò vào trong ứng dụng của mình liền.\nDemo: Mình sẽ demo iframe bằng cách gắn một app khác (app products hiện thị các sản phẩm liên quan) vào một app chính như hình bên dưới.\nSource code\r\rDemo\r\r"},{"id":1,"href":"/docs/table-of-contents/when-to-use/","title":"Khi nào ta nên nghĩ tới việc sử dụng Micro Frontends","section":"Micro Frontends","content":"Khi nào ta nên nghĩ tới việc sử dụng Micro Frontends\r#\r\rMột số trường hợp sau đây, chúng ta có thể sử dụng Micro Frontends\nCó thể bạn sẽ muốn phát triển một progressive hoặc responsive web application nhưng bạn gặp khó khăn trong việc tích hợp vào source code hiện tại của mình\nCó thể bạn muốn sử dụng một thư viện mới để tăng tốc quá trình phát triển sản phẩm của mình (vd: trước đó sử dụng Angularjs (1.x) để phát triển và hiện tại muốn sử dụng ReactJS để phát triển)\nCó thể bạn muốn sử dụng một thư viện mới để tăng tốc quá trình phát triển sản phẩm của mình (vd: trước đó sử dụng Angularjs (1.x) để phát triển và hiện tại muốn sử dụng ReactJS để phát triển)\nBạn muốn sử dụng một thư viện mới để hỗ trợ cho các chức năng sản phẩm, như sử dụng Webpack 5.x nhưng project hiện tại đang sử dụng Webpack 3.x và khó có thể nâng cấp lên Webpack 5.x được vì có khá nhiều dependence bị ảnh hưởng.\nCó thể bạn muốn tăng tốc quá trình phát triển sản phẩm bằng cách nhiều team khác nhau tham gia vào phát triển một sản phẩm cùng lúc bằng việc tách ra nhiều module và phát triển độc lập.\n"},{"id":2,"href":"/docs/table-of-contents/advantages-and-disadvantages/","title":"Một số ưu điểm và nhược điểm của Micro Frontends","section":"Micro Frontends","content":"Một số ưu điểm và nhược điểm của Micro Frontends\r#\r\rƯu điểm\r#\r\rTách biệt các module chức năng thành nhiều phần source code riêng biệt. Từ đó giảm các dependence ở mỗi project, lượng code sẽ ít hơn, giúp cho quá trình build deploy nhanh hơn và các file js bundle cũng sẽ nhẹ hơn\nCó khả năng mở rộng một cách dễ dàng bằng cách nhiều team cùng tham gia\nCó khả năng nâng cấp, cập nhật thư viện hoặc phát triển lại một phần nào đó của dự án\nDễ dàng kiểm thử (testing) các chức năng một cách độc lập\nNhược điểm\r#\r\rChia nhỏ các dự án sẽ dẫn tới trùng lập các dependences hoặc source code\nNhiều team phát triển nên khó trong việc quản lý source code nếu không có quy định chung rõ ràng từ ban đầu\n"},{"id":3,"href":"/docs/example/run-time-integration/","title":"Run-time integration via JavaScript","section":"Ví dụ","content":"Run-time integration via JavaScript\r#\r\rTrong React thông thường file index.jsx ta sẽ render \u0026lt;App /\u0026gt; vào trong một div element có id là root như \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\n// /run-time-integration/products/src/index.jsx import React from \u0026#34;react\u0026#34;; import ReactDOM from \u0026#34;react-dom\u0026#34;; import App from \u0026#34;./App\u0026#34;; ReactDOM.render(\u0026lt;App /\u0026gt;, document.getElementById(\u0026#34;root\u0026#34;)); Ta sẽ chỉnh lại như sau, khai báo một function global renderProducts truyển vào parameter containerId và tiến hành sử dụng ReactDOM render \u0026lt;App /\u0026gt; vào trong element này.\n// /run-time-integration/products/src/index.jsx import React from \u0026#34;react\u0026#34;; import ReactDOM from \u0026#34;react-dom\u0026#34;; import App from \u0026#34;./App\u0026#34;; window.renderProducts = (containerId, history) =\u0026gt; { ReactDOM.render( \u0026lt;App history={history} /\u0026gt;, document.getElementById(containerId), ); }; Trong file index.html của container, ta load script file bundle của project products và sau đó gọi global function renderProducts để render app products vào trong ứng dụng container\n\u0026lt;!-- /run-time-integration/container/public/index.html --\u0026gt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;The Model Store\u0026lt;/title\u0026gt; \u0026lt;link href=\u0026#34;https://unpkg.com/tailwindcss@2.2.7/dist/tailwind.min.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; \u0026lt;!-- Load file bundle của project products --\u0026gt; \u0026lt;script src=\u0026#34;http://localhost:8002/main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;root\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- Gọi function renderProducts để render app products vào element id có name products --\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; window.onload = () =\u0026gt; { window.renderProducts(\u0026#39;products\u0026#39;) } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Và kết quả sẽ như sau, ứng dụng container đã có thêm phần Related products của ứng dụng products Source code\r\rDemo\r\r"},{"id":4,"href":"/docs/table-of-contents/method/","title":"Một số phương pháp triển khai Micro Frontends","section":"Micro Frontends","content":"Một số phương pháp triển khai Micro Frontends\r#\r\rBuild-time integration\r#\r\rlà việc coi các ứng dụng như một package và ứng dụng chính sẽ thêm các ứng dụng con như một thư viện như sau:\n{ \u0026#34;name\u0026#34;: \u0026#34;@feed-me/container\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;A food delivery web app\u0026#34;, \u0026#34;dependencies\u0026#34;: { \u0026#34;@feed-me/browse-restaurants\u0026#34;: \u0026#34;^1.2.3\u0026#34;, \u0026#34;@feed-me/order-food\u0026#34;: \u0026#34;^4.5.6\u0026#34;, \u0026#34;@feed-me/user-profile\u0026#34;: \u0026#34;^7.8.9\u0026#34; } } Cách tiếp cận này có một số hạn chế như:\n Chúng ta sẽ phải re-compile (bundle) các ứng dụng chính và release lại mỗi khi các ứng dụng con có thay đổi (release version mới từ 0.0.1 ⇒ 0.02) Không có sự đồng bộ chức năng giữa các ứng dụng chính nếu chúng ta bỏ xót quá trình đồng bộ version của ứng dụng con (Cũng có thể là một điểm lợi nếu chúng ta không muốn nâng cấp chức năng ở một trang nào đó) Phụ thuộc các dependences với nhau  Nếu project @feed-me/container sử dụng React và @feed-me/browse-restaurants cũng sử dụng React thì sẽ bị trùng lập thư viện và tăng dung lượng khi tải trang web Nếu project @feed-me/container sử dụng React và @feed-me/browse-restaurants sử dụng chung React với project chính thì sẽ bị phụ thuộc vào version của project chính.    Run-time integration via iframes\r#\r\r\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Feed me!\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Welcome to Feed me!\u0026lt;/h1\u0026gt; \u0026lt;iframe id=\u0026#34;micro-frontend-container\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; const microFrontendsByRoute = { \u0026#39;/\u0026#39;: \u0026#39;https://browse.example.com/index.html\u0026#39;, \u0026#39;/order-food\u0026#39;: \u0026#39;https://order.example.com/index.html\u0026#39;, \u0026#39;/user-profile\u0026#39;: \u0026#39;https://profile.example.com/index.html\u0026#39;, }; const iframe = document.getElementById(\u0026#39;micro-frontend-container\u0026#39;); iframe.src = microFrontendsByRoute[window.location.pathname]; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Mỗi lần thay đổi url từ https://acb.com/ sang https://acb.com/order-food phần nội dụng của trang sẽ được tải lại bởi một nội dung từ domain khác, trong ví dụ là https://order.example.com/index.html.\nƯu điểm:\n Không bị ảnh hưởng bởi styles (CSS) giữa các trang chính và trang trong iframe  Hạn chế:\n Phải tải lại toàn bộ trang khi thay đổi đường dẫn Khó khăn trong việc giao tiếp giữa các chức năng  Tham khảo ví dụ: https://micro-frontends.tuando.net/docs/example/iframes/\nRun-time integration via JavaScript\r#\r\rTham khảo ví dụ: https://micro-frontends.tuando.net/docs/example/web-components/\nRun-time integration via Web Components\r#\r\rCách tiếp cận này cho phép chúng ta khai báo một HTML Custom Element, ví dụ như ta khai báo một HTML Custom Element \u0026lt;footer-order\u0026gt;\u0026lt;/footer-order\u0026gt; thì chỗ nào muốn sử dụng ta chỉ cần chèn đoạn mã \u0026lt;footer-order\u0026gt;\u0026lt;/footer-order\u0026gt; là có thể sử dụng được rồi.\nTham khảo ví dụ: https://micro-frontends.tuando.net/docs/example/web-components/\nModule Federation Webpack 5\r#\r\rModule Federation là một tính năng mới của Webpack 5. Nó cho phép chúng ta cấu hình để một ứng dụng có thể dynamic load code từ một ứng dụng khác.\nHiểu đơn giản là chúng ta có 2 ứng dụng được phát triển độc lập A và B, ứng dụng B là một phần nhỏ chức năng của ứng dụng A. Module Federation sẽ cho phép ta nhúng ứng dụng B và ứng dụng A và chia sẻ tài nguyên giữa chúng.\nChi tiết các bạn tham khảo tài liệu tại Module Federation và các ví dụ tại Module Federation Examples\nTham khảo ví dụ:\nReact: https://micro-frontends.tuando.net/docs/example/react-example/\nReact: https://micro-frontends.tuando.net/docs/example/react-redux/\nTài liệu tham khảo:\r#\r\rhttps://martinfowler.com/articles/micro-frontends.html\nhttps://micro-frontends.org/\n"},{"id":5,"href":"/docs/example/web-components/","title":"Web components","section":"Ví dụ","content":"Web components\r#\r\rSource code\r\rDemo\r\r"},{"id":6,"href":"/docs/example/react-example/","title":"Module Federation React Example","section":"Ví dụ","content":"Module Federation React Example\r#\r\rSource code\r\rDemo\r\r"},{"id":7,"href":"/docs/example/react-redux/","title":"Module Federation React Redux","section":"Ví dụ","content":"Module Federation React Redux\r#\r\rSource code\r\rDemo\r\r"},{"id":8,"href":"/posts/post-one/","title":"Post One","section":"Posts","content":"posts post one\n"}]